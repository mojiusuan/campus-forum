# ç®¡ç†å‘˜ç®¡ç†é¢æ¿ - å…³é”®ä»£ç ç¤ºä¾‹

## ğŸ” åç«¯æƒé™ä¸­é—´ä»¶ç¤ºä¾‹

### `backend/src/middleware/adminAuth.ts`

```typescript
import type { Request, Response, NextFunction } from 'express-serve-static-core';
import { sendError } from '../utils/response.js';
import { ErrorCode } from '../types/api.js';
import prisma from '../utils/db.js';

// æ‰©å±•Requestç±»å‹
declare global {
  namespace Express {
    interface Request {
      user?: {
        userId: string;
        email: string;
        role?: string;
      };
    }
  }
}

/**
 * è¦æ±‚ç®¡ç†å‘˜æƒé™
 */
export async function requireAdmin(
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> {
  try {
    if (!req.user?.userId) {
      sendError(res, ErrorCode.UNAUTHORIZED, 'éœ€è¦ç™»å½•', undefined, 401);
      return;
    }

    // æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯ï¼ˆåŒ…å«è§’è‰²ï¼‰
    const user = await prisma.user.findUnique({
      where: { id: req.user.userId },
      select: { id: true, role: true, isActive: true },
    });

    if (!user) {
      sendError(res, ErrorCode.NOT_FOUND, 'ç”¨æˆ·ä¸å­˜åœ¨', undefined, 404);
      return;
    }

    if (!user.isActive) {
      sendError(res, ErrorCode.FORBIDDEN, 'è´¦æˆ·å·²è¢«ç¦ç”¨', undefined, 403);
      return;
    }

    if (user.role !== 'admin' && user.role !== 'super_admin') {
      sendError(res, ErrorCode.FORBIDDEN, 'éœ€è¦ç®¡ç†å‘˜æƒé™', undefined, 403);
      return;
    }

    // å°†è§’è‰²ä¿¡æ¯æ·»åŠ åˆ°req.user
    req.user.role = user.role;

    next();
  } catch (error: any) {
    sendError(res, ErrorCode.INTERNAL_ERROR, error.message || 'æƒé™éªŒè¯å¤±è´¥');
  }
}

/**
 * è¦æ±‚è¶…çº§ç®¡ç†å‘˜æƒé™
 */
export async function requireSuperAdmin(
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> {
  try {
    if (!req.user?.userId) {
      sendError(res, ErrorCode.UNAUTHORIZED, 'éœ€è¦ç™»å½•', undefined, 401);
      return;
    }

    const user = await prisma.user.findUnique({
      where: { id: req.user.userId },
      select: { id: true, role: true, isActive: true },
    });

    if (!user || !user.isActive) {
      sendError(res, ErrorCode.FORBIDDEN, 'è´¦æˆ·å·²è¢«ç¦ç”¨', undefined, 403);
      return;
    }

    if (user.role !== 'super_admin') {
      sendError(res, ErrorCode.FORBIDDEN, 'éœ€è¦è¶…çº§ç®¡ç†å‘˜æƒé™', undefined, 403);
      return;
    }

    req.user.role = user.role;
    next();
  } catch (error: any) {
    sendError(res, ErrorCode.INTERNAL_ERROR, error.message || 'æƒé™éªŒè¯å¤±è´¥');
  }
}
```

---

## ğŸ“ æ“ä½œæ—¥å¿—å·¥å…·ç¤ºä¾‹

### `backend/src/utils/adminLog.ts`

```typescript
import prisma from './db.js';

export type AdminAction =
  | 'delete_post'
  | 'restore_post'
  | 'pin_post'
  | 'unpin_post'
  | 'lock_post'
  | 'unlock_post'
  | 'delete_comment'
  | 'restore_comment'
  | 'ban_user'
  | 'unban_user'
  | 'update_user'
  | 'delete_user'
  | 'reset_password'
  | 'create_category'
  | 'update_category'
  | 'delete_category'
  | 'reorder_categories'
  | 'delete_resource';

export type TargetType = 'post' | 'user' | 'comment' | 'category' | 'resource';

interface LogAdminActionParams {
  adminId: string;
  action: AdminAction;
  targetType?: TargetType;
  targetId?: string;
  description?: string;
  req?: { ip?: string; headers?: { 'user-agent'?: string } };
}

/**
 * è®°å½•ç®¡ç†å‘˜æ“ä½œæ—¥å¿—
 */
export async function logAdminAction(params: LogAdminActionParams): Promise<void> {
  try {
    const { adminId, action, targetType, targetId, description, req } = params;

    await prisma.adminLog.create({
      data: {
        adminId,
        action,
        targetType: targetType || null,
        targetId: targetId || null,
        description: description || null,
        ipAddress: req?.ip || null,
        userAgent: req?.headers?.['user-agent'] || null,
      },
    });
  } catch (error) {
    // æ—¥å¿—è®°å½•å¤±è´¥ä¸åº”å½±å“ä¸»æµç¨‹
    console.error('è®°å½•æ“ä½œæ—¥å¿—å¤±è´¥:', error);
  }
}
```

---

## ğŸ® ç®¡ç†å‘˜æ§åˆ¶å™¨ç¤ºä¾‹

### `backend/src/controllers/admin.post.controller.ts`

```typescript
import type { Request, Response } from 'express-serve-static-core';
import { sendSuccess, sendError } from '../utils/response.js';
import { ErrorCode } from '../types/api.js';
import prisma from '../utils/db.js';
import { logAdminAction } from '../utils/adminLog.js';

/**
 * è·å–å¸–å­åˆ—è¡¨ï¼ˆç®¡ç†å‘˜è§†å›¾ï¼‰
 */
export async function getPosts(req: Request, res: Response) {
  try {
    const page = parseInt(req.query.page as string) || 1;
    const limit = Math.min(parseInt(req.query.limit as string) || 20, 100);
    const skip = (page - 1) * limit;

    const keyword = req.query.keyword as string | undefined;
    const categoryId = req.query.categoryId as string | undefined;
    const userId = req.query.userId as string | undefined;
    const status = req.query.status as string | undefined; // 'all' | 'deleted' | 'pinned' | 'locked'

    // æ„å»ºæŸ¥è¯¢æ¡ä»¶
    const where: any = {};

    // çŠ¶æ€ç­›é€‰
    if (status === 'deleted') {
      where.isDeleted = true;
    } else if (status === 'pinned') {
      where.isPinned = true;
      where.isDeleted = false;
    } else if (status === 'locked') {
      where.isLocked = true;
      where.isDeleted = false;
    } else {
      // 'all' æˆ–æœªæŒ‡å®šï¼šæ˜¾ç¤ºæ‰€æœ‰ï¼ˆåŒ…æ‹¬å·²åˆ é™¤ï¼‰
      // ä¸è®¾ç½® isDeleted æ¡ä»¶
    }

    if (categoryId) {
      where.categoryId = categoryId;
    }

    if (userId) {
      where.userId = userId;
    }

    if (keyword) {
      where.OR = [
        { title: { contains: keyword, mode: 'insensitive' } },
        { content: { contains: keyword, mode: 'insensitive' } },
      ];
    }

    // æŸ¥è¯¢å¸–å­
    const [posts, total] = await Promise.all([
      prisma.post.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: 'desc' },
        include: {
          user: {
            select: {
              id: true,
              username: true,
              avatarUrl: true,
            },
          },
          category: {
            select: {
              id: true,
              name: true,
              slug: true,
            },
          },
        },
      }),
      prisma.post.count({ where }),
    ]);

    const totalPages = Math.ceil(total / limit);

    sendSuccess(res, {
      posts,
      pagination: {
        page,
        limit,
        total,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1,
      },
    });
  } catch (error: any) {
    sendError(res, ErrorCode.INTERNAL_ERROR, error.message || 'è·å–å¸–å­åˆ—è¡¨å¤±è´¥');
  }
}

/**
 * åˆ é™¤å¸–å­ï¼ˆç¡¬åˆ é™¤ï¼‰
 */
export async function deletePost(req: Request, res: Response) {
  try {
    const { id } = req.params;
    const adminId = req.user!.userId;

    // æŸ¥æ‰¾å¸–å­
    const post = await prisma.post.findUnique({
      where: { id },
      include: { category: true },
    });

    if (!post) {
      sendError(res, ErrorCode.NOT_FOUND, 'å¸–å­ä¸å­˜åœ¨');
      return;
    }

    // ç¡¬åˆ é™¤å¸–å­ï¼ˆçº§è”åˆ é™¤è¯„è®ºã€ç‚¹èµã€æ”¶è—ï¼‰
    await prisma.post.delete({
      where: { id },
    });

    // æ›´æ–°åˆ†ç±»ç»Ÿè®¡
    await prisma.category.update({
      where: { id: post.categoryId },
      data: {
        postCount: {
          decrement: 1,
        },
      },
    });

    // è®°å½•æ“ä½œæ—¥å¿—
    await logAdminAction({
      adminId,
      action: 'delete_post',
      targetType: 'post',
      targetId: id,
      description: `åˆ é™¤å¸–å­: ${post.title}`,
      req,
    });

    sendSuccess(res, { message: 'å¸–å­å·²åˆ é™¤' });
  } catch (error: any) {
    sendError(res, ErrorCode.INTERNAL_ERROR, error.message || 'åˆ é™¤å¸–å­å¤±è´¥');
  }
}

/**
 * ç½®é¡¶å¸–å­
 */
export async function pinPost(req: Request, res: Response) {
  try {
    const { id } = req.params;
    const adminId = req.user!.userId;

    const post = await prisma.post.update({
      where: { id },
      data: { isPinned: true },
    });

    await logAdminAction({
      adminId,
      action: 'pin_post',
      targetType: 'post',
      targetId: id,
      description: `ç½®é¡¶å¸–å­: ${post.title}`,
      req,
    });

    sendSuccess(res, { message: 'å¸–å­å·²ç½®é¡¶' });
  } catch (error: any) {
    sendError(res, ErrorCode.INTERNAL_ERROR, error.message || 'ç½®é¡¶å¸–å­å¤±è´¥');
  }
}
```

---

## ğŸ¨ å‰ç«¯æƒé™ç»„ä»¶ç¤ºä¾‹

### `frontend/src/components/AdminRoute.tsx`

```typescript
import { Navigate } from 'react-router-dom';
import { useAuthStore } from '../store/authStore';

interface AdminRouteProps {
  children: React.ReactNode;
}

export default function AdminRoute({ children }: AdminRouteProps) {
  const { user, isAuthenticated } = useAuthStore();

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  if (user?.role !== 'admin' && user?.role !== 'super_admin') {
    return <Navigate to="/" replace />;
  }

  return <>{children}</>;
}
```

### `frontend/src/hooks/useAdmin.ts`

```typescript
import { useAuthStore } from '../store/authStore';

export function useIsAdmin(): boolean {
  const { user } = useAuthStore();
  return user?.role === 'admin' || user?.role === 'super_admin';
}

export function useIsSuperAdmin(): boolean {
  const { user } = useAuthStore();
  return user?.role === 'super_admin';
}

export function useRequireAdmin() {
  const isAdmin = useIsAdmin();
  
  if (!isAdmin) {
    throw new Error('éœ€è¦ç®¡ç†å‘˜æƒé™');
  }
  
  return true;
}
```

---

## ğŸ“Š å‰ç«¯ç®¡ç†é¡µé¢ç¤ºä¾‹

### `frontend/src/pages/admin/AdminDashboard.tsx`

```typescript
import { useQuery } from '@tanstack/react-query';
import { adminApi } from '../../api/admin';
import AdminLayout from '../../components/admin/AdminLayout';

export default function AdminDashboard() {
  const { data: stats, isLoading } = useQuery({
    queryKey: ['admin-stats-overview'],
    queryFn: () => adminApi.getOverviewStats(),
  });

  if (isLoading) {
    return <AdminLayout>åŠ è½½ä¸­...</AdminLayout>;
  }

  return (
    <AdminLayout>
      <div className="space-y-6">
        <h1 className="text-2xl font-bold">æ•°æ®æ¦‚è§ˆ</h1>
        
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
          <div className="bg-white p-6 rounded-lg shadow">
            <h3 className="text-sm text-gray-500">ç”¨æˆ·æ€»æ•°</h3>
            <p className="text-3xl font-bold mt-2">{stats?.data?.totalUsers || 0}</p>
          </div>
          
          <div className="bg-white p-6 rounded-lg shadow">
            <h3 className="text-sm text-gray-500">å¸–å­æ€»æ•°</h3>
            <p className="text-3xl font-bold mt-2">{stats?.data?.totalPosts || 0}</p>
          </div>
          
          <div className="bg-white p-6 rounded-lg shadow">
            <h3 className="text-sm text-gray-500">è¯„è®ºæ€»æ•°</h3>
            <p className="text-3xl font-bold mt-2">{stats?.data?.totalComments || 0}</p>
          </div>
          
          <div className="bg-white p-6 rounded-lg shadow">
            <h3 className="text-sm text-gray-500">ä»Šæ—¥æ–°å¢</h3>
            <p className="text-3xl font-bold mt-2">{stats?.data?.todayPosts || 0}</p>
          </div>
        </div>
      </div>
    </AdminLayout>
  );
}
```

---

## ğŸ”Œ APIå®¢æˆ·ç«¯ç¤ºä¾‹

### `frontend/src/api/admin.ts`

```typescript
import apiClient from './client';
import type { ApiResponse } from '../types/api';

export const adminApi = {
  // æ•°æ®ç»Ÿè®¡
  getOverviewStats: async (): Promise<ApiResponse<any>> => {
    const response = await apiClient.get('/admin/stats/overview');
    return response.data;
  },

  // å¸–å­ç®¡ç†
  getPosts: async (params?: {
    page?: number;
    limit?: number;
    keyword?: string;
    categoryId?: string;
    userId?: string;
    status?: string;
  }): Promise<ApiResponse<any>> => {
    const response = await apiClient.get('/admin/posts', { params });
    return response.data;
  },

  deletePost: async (id: string): Promise<ApiResponse> => {
    const response = await apiClient.delete(`/admin/posts/${id}`);
    return response.data;
  },

  pinPost: async (id: string): Promise<ApiResponse> => {
    const response = await apiClient.post(`/admin/posts/${id}/pin`);
    return response.data;
  },

  // ç”¨æˆ·ç®¡ç†
  getUsers: async (params?: {
    page?: number;
    limit?: number;
    keyword?: string;
    role?: string;
    status?: string;
  }): Promise<ApiResponse<any>> => {
    const response = await apiClient.get('/admin/users', { params });
    return response.data;
  },

  banUser: async (id: string, reason: string): Promise<ApiResponse> => {
    const response = await apiClient.post(`/admin/users/${id}/ban`, { reason });
    return response.data;
  },
};
```

---

è¿™äº›ä»£ç ç¤ºä¾‹å¯ä»¥ä½œä¸ºå¼€å‘çš„èµ·ç‚¹ã€‚æ ¹æ®å®é™…éœ€æ±‚è¿›è¡Œè°ƒæ•´å’Œå®Œå–„ã€‚
